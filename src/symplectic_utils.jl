# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
  
# Licensed under the Apache License, Version 2.0 (the "License").
# You may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
    symplectic_dual(M::Matrix)

Return Mdual which is the generator matrix for the symplectic dual lattice for the lattice
generated by M.

Note that Mdual = inv(A) * M where A = M * Ω * transpose(M) is the symplectic Gram matrix. 
Note that M has to be even dimensional. 
Note that Mdual is not unique. 

"""
function symplectic_dual(M::Matrix)
    N = size(M)[1]
    if N % 2 !=0 
        error("The symplectic dual is only defined for even-dimensional matrices.")
    end

    ω = [[0 1]; [-1 0]]
    Ω = BlockDiagonal([ω for _ in 1:floor(Int, N/2)])

    A = M * Ω * transpose(M)

    Mdual = inv(A) * M
    
    return Mdual
end



"""
    general_symplectic(N::Int, method::String = "Bloch_Messiah")

Return a parametric function for generic 2Nx2N real-valued symplectic matrix. 

There are two options for method. 

option 1: "generator" (or any string other than the default one, for now)

We will follow the link [here](https://en.wikipedia.org/wiki/Classical_group#Sp(m,_R)_%E2%80%93_the_real_symplectic_group:~:text=Sp(m%2C%20R)%20%E2%80%93%20the%20real%20symplectic%20group%5Bedit%5D) 
to first calculate the generator of the 2Nx2N real-valued symplectic matrix, 
followed by exponentiate it.

For a 2Nx2N real-valued symplectic matrix, the generator is of the form
[X, Y; Z, -X^T]  where Y,Z are NxN real-valued symmetric matrix, and X
is a general NxN real-valued matrix. Hence the number of parameters are
2*N*(N+1)/2 + N^2 = 2N^2 + N. 

The convention we used for this option is the following: The first N^2 
parameters will be allocated for X, the next N*(N+1)/2 will be for Y, 
and the very last N*(N+1)/2 parameters for Z.


option 2 (default): "Bloch_Messiah"

In this option, we follow the link [here](https://strawberryfields.ai/photonics/conventions/decompositions.html#Bloch_Messiah-or-euler-decomposition).
to write the decomposition of a symplectic matrix as S = O1 * Z * O2 where 
O1, O2 are orthogonal symplectic, and Z = (exp-r1, exp(r1), exp-r2, exp(r2), ...).
Do not confuse with the Z here and the one above...

For orthogonal symplectic matrix, its generators will not only have the other 
form, but also be anti-symmetric, hence it has only N(N-1)/2 + N*(N+1)/2 = N^2 
free parameters. Hence in this representation, the number of parameters for S is
2N^2+N, which is consistent. 

The convention we used for this option is the following: The first N
parameters will be allocated for Z, the next N^2 will be for O1, and the very 
last N*(N+1)/2 parameters for O2. 
    
"""
function general_symplectic(N::Int; method::String = "Bloch_Messiah")

    T = basis_transformation(N)
    if method == "Bloch_Messiah"
        function S1(args)
            @assert length(args) == 2*N^2 + N
            Z = reduce(vcat, [[exp(r), exp(-r)] for r in args[1:N]])

            S_orthogonal = orthogonal_symplectic(N)

            O1 = S_orthogonal(args[N+1:N+N^2])
            O2 = S_orthogonal(args[N^2+N+1:2N^2+N])
            S0 = O1 * Diagonal(Z) * O2
            return S0
            
        end
        return S1
    else
        function S2(args) # do not use the same function name as S1
            @assert length(args) == 2*N^2 + N
            X = reshape(args[1:N^2], N,N) # construct X
            Y = [ i<=j ? args[N^2 + Int(j*(j-1)/2+i)] : args[N^2 + Int(i*(i-1)/2+j)] for i=1:N, j=1:N]
            Z = [ i<=j ? args[N^2 + Int(N*(N+1)/2) + Int(j*(j-1)/2+i)] : args[N^2 + Int(N*(N+1)/2) + Int(i*(i-1)/2+j)] for i=1:N, j=1:N]

            generator = vcat(hcat(X, Y), hcat(Z, -transpose(X)))
            S0 = exp(generator)

            return transpose(T) * S0 * T
        end
        return S2
    end
    
end




"""
    orthogonal_symplectic(N::Integer)

Return a parametric function for 2Nx2N real-valued orthogonal symplectic matrix. 

We will follow the link [here](https://en.wikipedia.org/wiki/Classical_group#Sp(m,_R)_%E2%80%93_the_real_symplectic_group:~:text=Sp(m%2C%20R)%20%E2%80%93%20the%20real%20symplectic%20group%5Bedit%5D) 
to first calculate the generator of the 2Nx2N real-valued symplectic matrix, 
followed by exponentiate it.

For a 2Nx2N real-valued orthogonal symplectic matrix, the generator is of the form
[X, Y; -Y, -X^T]  where Y is NxN real-valued symmetric matrix, and X
is an NxN real-valued anti-symmetric matrix. Hence the number of parameters is N^2

The convention we used for this option is the following: The first N(N-1)/2 parameters
will be allocated for X, the next N*(N+1)/2 will be for Y. 

Note that the Bloch_Messiah decomposition for the orthogonal symplectic matrix is trivial. 
    
"""
function orthogonal_symplectic(N::Integer)

    T = basis_transformation(N)
    function S(args)
        @assert length(args) == N^2
        k = 0
        generator = zeros(2*N, 2*N)
        for i = 1 : N
            for j = i+1 : N
                k += 1
                generator[i,j] = args[k] 
            end
        end
        for i = 1 : N
            for j = N+i : 2N
                k += 1
                generator[i,j] = args[k] 
                generator[j-N,i+N] = args[k] 
            end
        end
        generator[N+1:2N, N+1:2N] = generator[1:N, 1:N]

        generator = generator - transpose(generator)
        S0 = exp(generator)
        return transpose(T) * S0 * T
    end
end


"""
    bloch_messiah(S::Matrix)

Return O1, Z, O2 such that S = O1 * Z * O2 is the Bloch-Messiah decomposition of the symplectic matrix S.
Here O1, O2 are orthogonal symplectic matrices, and Z = diag(exp(-r1), exp(r1), ..., exp(-rN), exp(rN))

Ref 1: https://math.stackexchange.com/questions/1886038/finding-euler-decomposition-of-a-symplectic-matrix
Ref 2: https://strawberryfields.ai/photonics/conventions/decompositions.html#bloch-messiah-or-euler-decomposition
Ref 3: https://strawberryfields.readthedocs.io/en/stable/_modules/strawberryfields/decompositions.html#bloch_messiah

"""
function bloch_messiah(S::Matrix)
    Σ = sqrt(S * transpose(S));
    val, vec = eigen(Σ)
    Ω = BlockDiagonal([[0 1; -1 0] for _ in 1 : Int(size(S)[1]/2)])

    # # shuffle the order of val and vec
    ind = sortperm(val)
    vec = vec[:, ind]
    val = val[ind];
    
    U = transpose(vec)
    
    A = U * Ω * transpose(U) # We can show that A is always a matrix with only off-diagonal elements, and the entries are ±1
    R, _ = canonical_form_of_anti_symmetric_matrix(A) # R * A * transpose(R) = A2
    O1 = transpose(R * U)
    
    Z = transpose(inv(R)) * Diagonal(val) * inv(R)

    O2 = inv(O1) * inv(Σ) * S

    return O1, Z, O2
    
end


"""
    get_orthogonal_symplectic_parameters(S::Matrix)

Return the parameters for the orthogonal symplectic matrix S. 

The convention for the order of the parameters follow that of 
`orthogonal_symplectic(N::Integer)`
"""
function get_orthogonal_symplectic_parameters(S::Matrix)
    N = Int(size(S)[1]/2)
    T = basis_transformation(N)
    S0 = T * S * transpose(T)
    generator = log(S0)
    args = []
    for i = 1: N
        for j = i+1:N
            push!(args, generator[i,j])
        end
        for j = N+i:2N
            push!(args, generator[i,j])
        end
    end
    return args
end

