# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
  
# Licensed under the Apache License, Version 2.0 (the "License").
# You may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
get_grid_points_2DLattice(M:: Matrix, xlim::Number, ylim::Number)

Return a set of grid points of a 2D lattice generated by M, in a rectangular region 
defined by [-xlim, xlim, -ylim, ylim]. 

Note: M has to be a 2x2 matrix.
"""
function get_grid_points_2D_lattice(M:: Matrix, xlim::Number, ylim::Number)
    if size(M) != (2, 2)
        error("M has to be a 2x2 matrix.")
    end
    xlim, ylim = abs(xlim), abs(ylim)

    v1, v2 = M[1, :], M[2, :]
    v1num = floor(Int, min(abs(xlim/v1[1]), abs(ylim/v1[2])))
    v2num = floor(Int, min(abs(xlim/v2[1]), abs(ylim/v2[2])))
    pts = []
    for i in -v1num:v1num
        for j in -v2num:v2num
            push!(pts, i * v1 + j * v2)
        end
    end

    return pts
end


"""
    basis_transformation(N::Integer)

Return the matrix that transform from the (q1,q2... qN,p1,p2... pN) basis to (q1,p1,q2,p2, ...qN, pN) basis.

Note: M2 = T * M * transpose(T) where M is in (q1,p1,q2,p2, ...qN, pN) basis, and M2 is in (q1,q2... qN,p1,p2... pN) basis.
"""
function basis_transformation(N::Integer)
    # change from (q1,q2..,p1,p2) basis to (q1,p1,q2,p2, ...) basis
    T = zeros(2*N, 2*N)
    for i = 1 : 2*N
        if i <= N
            T[i, 2i-1] = 1
        else
            T[i, 2(i-N)] = 1
        end
    end
    return round.(Int, T)
end


"""
    canonical_form_of_anti_symmetric_matrix(A::Matrix)

Return R, A2 such that A2 = R * A * transpose(R) is the canonical form of A. 

Here A is an NxN anti-symmetric matrix. 
"""
function canonical_form_of_anti_symmetric_matrix(A::Matrix)

    if !(round.(Int, A) ≈ A)
        error("The matrix A has to be integer valued.")
    end
    A = round.(Int, A)

    R1, A = anti_symmetric_matrix_to_tridiagonal_matrix(A)
    R2, A2 = canonical_form_of_tridiagonal_anti_symmetric_matrix(A)

    R = R2 * R1
    
    return R, A2
end




######## Below are helper functions for `canonical_form_of_anti_symmetric_matrix`

function gcd_extended(a::Int, b::Int)
    """
    Given two integers, a and b, return gcd, x, y such that ax+by = gcd is the greatest common divisor of a, b
    # Ref: https://www.geeksforgeeks.org/python-program-for-basic-and-extended-euclidean-algorithms-2/
    """
    # Base Case 
    if a==0
        return b, 0, 1
    end

    gcd, x1, y1 = gcd_extended(abs(b) % abs(a), abs(a))
    # Update x and y using results of recursive call 
    x = y1 - floor(Int, abs(b)/abs(a)) * x1 
    y = x1 

    if gcd < 0 # make sure gcd is positive
        x, y = -x, -y
    end
    x, y = sign(a) * x, sign(b) * y 

    # To make sure the type of returns are correct 
    return floor(Int, gcd), floor(Int, x), floor(Int, y)    
end

function gcd_for_list(vec)
    """ Given a list of integers, find their gcd
    """
    # Find the GCD of the list
    gcd, _, _ = gcd_extended(vec[1], vec[2])

    for (i, a) in enumerate(vec[3:end])
        # print(i)
        gcd, _, _ = gcd_extended(gcd, a) ;
    end

    return gcd
end


function put_last_row_to_zero(A::Matrix)
    """Given an integer valued anti-symmetric matrix A, return R, A2 such that
    A2 = R * A * transpose(R). The last row and col of A2 are all 0 except that 
    A2[end-1,end] = -A2[end,end-1] are nonzero. R is an unimodular matrix.
    """

    N = size(A)[1] # dimension of A
    R = Matrix{Int}(I, N, N)

    if N==2
        return R, A
    end

    # From right to left, find the first nonzero element in the last row
    ind = N
    for i in N-1:-1:1
        if A[end, i] != 0
            ind = i
            break
        end 
    end    

    if ind == N # If the last row are all zeros, then return 
        return R, A
    end

    A12 = A[end, ind] # The val of the first nonzero element A[N-1, N] (call it A12 for convenience and historical reason)

    for i in ind-1:-1:1
        if A[end, i] != 0
            gcd, x, y = gcd_extended(A12, A[end, i])
            R2 = Matrix{Int}(I, N, N)
            R2[ind, ind], R2[ind, i], R2[i, ind], R2[i, i] = x, y, -floor(A[end, i]/gcd), floor(A12/gcd)
            A12 = gcd
            R = R2 * R
        end
    end

    # Swap the rows such that A[N-1, N] is nonzero
    if ind != N-1
        R3 = Matrix{Int}(I, N, N)
        R3[N-1,N-1], R3[N-1,ind], R3[ind,N-1], R3[ind,ind] = 0, 1, 1, 0
        R = R3 * R
    end

    # Get the desired A
    A = R * A * transpose(R)

    return R, A
end

function anti_symmetric_matrix_to_tridiagonal_matrix(A::Matrix)
    """Given a NxN anti-symmetric matrix A, return R, A2 such that 
    A2 = R * A * transpose(R). A2 is a tridiagonal antisymmetric matrix. R is an unimodular matrix.

    Note that the tridiagonal form of an anti-symmetric matrix needs not be unique, which may depend on 
    the order of how the rows are eliminated. 
    """

    N = size(A)[1] # dimension of A

    if N<=2
        return Matrix{Int}(I, N, N), A
    end

    # First put the last row of A to zero except A[N-1, N] and A[N, N-1]
    R1, A = put_last_row_to_zero(A)

    # Then put the N-1xN-1 submatrix of A to be the tridiagonal form
    A2 = A[1:end-1, 1:end-1]
    R2, A2 = anti_symmetric_matrix_to_tridiagonal_matrix(A2)

    # substitute back to A
    A[1:end-1, 1:end-1] = A2    

    # Define the R matrix 
    R3 = zeros(Int, N, N)
    R3[end,end] = 1
    R3[1:end-1, 1:end-1] = R2
    R = R3 * R1

    return R, A
    
end

function canonical_form_of_tridiagonal_anti_symmetric_matrix(A::Matrix)
    """Given a NxN tridiagonal skew-symmetric matrix A, return R, A2 such that A2 = R * A * transpose(R), 
    which is the canonical form of A. We note 
    A2 = ⨊_i d_i * ω where ω = [0,1; -1, 0] for even dimension, and 
    A2 = [0] + ⨊_i d_i * ω where ω = [0,1; -1, 0] for odd dimension where the first row and col are zeros
    We make sure that |d_1| ≥ |d_2| ≥ |d_3| ...
    """

    A = Matrix(A) # This is to make a copy of A
    N = size(A)[1] # dimension of A

    if N<=2
        # make sure the upper diagonal is positive
        if A[1,2] < A[2,1]
            R = [0 1; 1 0]
            A[1,2], A[2,1] = A[2,1], A[1,2]
        else
            R = Matrix{Int}(I, N, N)
        end
        return R, A
    end
    
    # lower tridiagonal entries for A
    tridiag = [A[i, i-1] for i in range(2, N)]
    gcd = gcd_for_list(tridiag)

    R = Matrix{Int}(I, N, N)
    if abs(gcd) != abs(tridiag[end])
        # If A[N-1, N] does not divides all the entries in the lower tridiagonal elements, then add all the rows
        # to the very last row, and reduce the resultant matrix to tridiagonal form 
        R1 = Matrix{Int}(I, N, N)
        R1[end, :] = fill(1, (1,N)) 
        A = R1 * A * transpose(R1)
        R2, A = anti_symmetric_matrix_to_tridiagonal_matrix(A)

        R = R2 * R1
    end

    # It is now guaranteed that A[N-1, N] divides all the entries in the lower tridiagonal elements. 
    # Hence A[N-1, N] can be used to eliminate A[N-2, N-1] and A[N-1, N-2]
    R3 = Matrix{Int}(I, N, N)
    R3[end-2,end] = floor(Int, -A[end-2,end-1]/A[end,end-1]) # floor is to make sure the type is correct
    A[end-1,end-2], A[end-2,end-1] = 0, 0

    # Put the N-2xN-2 submatrix into canonical form
    A2 = A[1:end-2, 1:end-2]
    R4, A2 = canonical_form_of_tridiagonal_anti_symmetric_matrix(A2)

    R5 = zeros(Int, N, N)
    R5[end-1,end-1], R5[end,end] = 1, 1
    R5[1:end-2, 1:end-2] = R4

    A[1:end-2, 1:end-2] = A2

    R = R5 * R3 * R

    # Flip the entries such that the upper diagonal is positive
    if N % 2 == 1
        i0 = 2 # if N is odd, then the first row and col are zeros, thus ignored
    else
        i0 = 1 
    end

    for i in i0:N-1
        if A[i,i+1] < A[i+1,i]
            
            R6 = Matrix{Int}(I, N, N)
            R6[i+1,i], R6[i,i+1], R6[i+1,i+1], R6[i,i] = 1, 1, 0, 0
            R = R6 * R
            A[i,i+1], A[i+1,i] = A[i+1,i], A[i,i+1]
        end
    end    

    return R, A
    
end


