# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
  
# Licensed under the Apache License, Version 2.0 (the "License").
# You may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
    Ω_matrix(M::Matrix)

Return the standard symplectic matrix Ω with the same size as M

Note that M has to be square and even dimensional.
"""
function Ω_matrix(M::Matrix)
    dim = size(M)[1]
    if dim % 2 !=0 
        error("Dimension of M should be even")
    end
    
    ω = [0 1; 
        -1 0]
    Ω = BlockDiagonal([ω for _ in 1:round(Int, dim/2)])
    
    return Ω
end

"""
    gram_matrix_of_GKP_lattice_generator(M::Matrix)

Return A = M * Ω * transpose(M) where Ω is the standard symplectic matrix. 

Note that M has to be square and even dimensional.
"""
function gram_matrix_of_GKP_lattice_generator(M::Matrix)
    Ω = Ω_matrix(M)
    A = M * Ω * transpose(M)
    
    if !(round.(Int, A)≈A)
        error("The Gram matrix for the generator matrix is not integral, hence the lattice generator does not generate a valid GKP code!")
    end
    A = round.(Int, A)
    return A
end

"""
    canonize_GKP_lattice_generator(M::Matrix)

Return Mp, Ap where Mp = R * M where R is the unimodular matrix such that Ap = R * A * transpose(R) 
is in the canonical form diag(d1,...,dN) ⊗ ω with non-negative integers d1,...,dN. 

Note that M has to be square and even dimensional. 
"""
function canonize_GKP_lattice_generator(M::Matrix)
    A = gram_matrix_of_GKP_lattice_generator(M)
    R, Ap = canonical_form_of_anti_symmetric_matrix(A)
    Mp = R * M
    
    return Mp, Ap
end

"""
    GKP_logical_operator_generator(M::Matrix)

Return Mperp = Ω * inv(A) * M where A = M * Ω * transpose(M), and Ω is the standard symplectic matrix.  

Note that M has to be square and even dimensional.
"""
function GKP_logical_operator_generator(M::Matrix)
    Ω = Ω_matrix(M)
    A = gram_matrix_of_GKP_lattice_generator(M)
    Mperp = Ω * inv(A) * M
    
    return Mperp
end

"""
    GKP_logical_operator_generator_canonical(M::Matrix, one_qubit::Bool)

Return Mperp = Ω * inv(Ap) * Mp where Ap = Mp * Ω * transpose(Mp), Ω is the standard symplectic matrix.  

Note that M has to be square and even dimensional, and Mp, the canonical form of M, can be obtained by `Mp, Ap = canonize_GKP_lattice_generator(M)`. 

If one_qubit is true, then we check if the lattice encode a single qubit, by checking if it yields d1=2 and d2=...=dN=1 in the canonical form
"""
function GKP_logical_operator_generator_canonical(M::Matrix; one_qubit::Bool=false)
    Mp, Ap = canonize_GKP_lattice_generator(M)

    if one_qubit
        # Confirm that d1 = 2, d2=...=dN=1
        for i = 1 : Int(size(Ap, 1)/2)
            if i == 1
                @assert Ap[1, 2] ≈ 2
            else
                @assert Ap[2i-1, 2i] ≈ 1
            end
        end
    end

    Mperp = GKP_logical_operator_generator(Mp)
    
    return Mperp
end


"""
    distance_X(M::Matrix)

Return the minimum distance of the logical X shift of the GKP code generated by M. 

Here the input matrix M is a 2N by 2N matrix and should yield d1=2 and d2=...=dN=1 in the canonical form. 
"""
function distance_X(M::Matrix)
    Mperp = GKP_logical_operator_generator_canonical(M, one_qubit=true)

    w1 = Mperp[1, :]
    w2 = Mperp[2, :]
    w1_T = transpose(w1)
    w2_T = transpose(w2)
    Mperp_prime = Mperp
    Mperp_prime[1, :] = 2 * w1
    Mperp_prime[2, :] = 2 * w2

    yX = closest_point(vec(w1_T), lll(Mperp_prime))
    dX = √(2π) * norm(w1_T - transpose(yX))
    
    return dX
end

"""
    distance_Z(M::Matrix)

Return the minimum distance of the logical Z shift of the GKP code generated by M. 

Here the input matrix M is a 2N by 2N matrix and should yield d1=2 and d2=...=dN=1 in the canonical form. 
"""
function distance_Z(M::Matrix)
    Mperp = GKP_logical_operator_generator_canonical(M, one_qubit=true)

    w1 = Mperp[1, :]
    w2 = Mperp[2, :]
    w1_T = transpose(w1)
    w2_T = transpose(w2)
    Mperp_prime = Mperp
    Mperp_prime[1, :] = 2 * w1
    Mperp_prime[2, :] = 2 * w2

    yZ = closest_point(vec(w2_T), lll(Mperp_prime))
    dZ = √(2π) * norm(w2_T - transpose(yZ))
    
    return dZ
end

"""
    distance_Y(M::Matrix)

Return the minimum distance of the logical Y shift of the GKP code generated by M. 

Here the input matrix M is a 2N by 2N matrix and should yield d1=2 and d2=...=dN=1 in the canonical form. 
"""
function distance_Y(M::Matrix)
    Mperp = GKP_logical_operator_generator_canonical(M, one_qubit=true)

    w1 = Mperp[1, :]
    w2 = Mperp[2, :]
    w1_T = transpose(w1)
    w2_T = transpose(w2)
    Mperp_prime = Mperp
    Mperp_prime[1, :] = 2 * w1
    Mperp_prime[2, :] = 2 * w2

    yY = closest_point(vec(w1_T+w2_T), lll(Mperp_prime))
    dY = √(2π) * norm(w1_T+w2_T - transpose(yY))

    return dY
end


"""
    distances(M::Matrix)

Return the X, Y, Z distances of a non-trivial logical shift of the GKP code generated by M. 

Here the input matrix M is a 2N by 2N matrix and should yield d1=2 and d2=...=dN=1 in the canonical form. 
"""
function distances(M::Matrix)
    Mperp = GKP_logical_operator_generator_canonical(M, one_qubit=true)

    w1 = Mperp[1, :]
    w2 = Mperp[2, :]
    w1_T = transpose(w1)
    w2_T = transpose(w2)
    Mperp_prime = Mperp
    Mperp_prime[1, :] = 2 * w1
    Mperp_prime[2, :] = 2 * w2

    yX = closest_point(vec(w1_T), lll(Mperp_prime))
    dX = √(2π) * norm(w1_T - transpose(yX))

    yZ = closest_point(vec(w2_T), lll(Mperp_prime))
    dZ = √(2π) * norm(w2_T - transpose(yZ))
    
    yY = closest_point(vec(w1_T+w2_T), lll(Mperp_prime))
    dY = √(2π) * norm(w1_T+w2_T - transpose(yY))

    return [dX, dY, dZ]
end

"""
    distance(M::Matrix)

Return the minimum distance of a non-trivial logical shift of the GKP code generated by M. 

Here the input matrix M is a 2N by 2N matrix and should yield d1=2 and d2=...=dN=1 in the canonical form. 
"""
distance(M::Matrix) = min(distances(M)...)

"""
    gaussian(σ::Float64, x::Vector{Float64})

Return the Gaussian probability of a vector x with variance σ.
"""
gaussian(σ::Float64, x::Float64) = 1/√(2π * σ^2) * exp(-x^2 / (2σ^2))

gaussian(σ::Float64, x::Vector{Float64}) = gaussian(σ, norm(x))
